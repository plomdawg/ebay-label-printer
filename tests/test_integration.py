"""
Integration tests for multi-module workflows
"""
# pylint: disable=attribute-defined-outside-init

from unittest.mock import Mock, patch

import pytest

from app.config import Config
from app.packing import PackingSlipGenerator
from app.print import PrintManager


class TestPackingAndPrintingIntegration:
    """Test integration between packing slip generation and printing"""

    def setup_method(self):
        """Set up test fixtures"""
        self.config = Mock(spec=Config)
        self.config.DRY_RUN = False

        self.packing_generator = PackingSlipGenerator(self.config)
        self.print_manager = PrintManager(self.config)

        # Sample order data for testing
        self.test_order = {
            "order_id": "TEST-001",
            "buyer_address": {
                "name": "Test Customer",
                "street": "123 Test St",
                "city": "Test City",
                "state": "TS",
                "postalCode": "12345",
            },
            "quantity": 1,
            "total": "15.99",
        }

    def test_generate_and_print_packing_slip_dry_run(self):
        """Test the full workflow: generate PDF and print it (dry run)"""
        self.config.DRY_RUN = True

        # Generate packing slip PDF
        pdf_path = self.packing_generator.generate_packing_slip(self.test_order)

        # Verify PDF was generated
        assert pdf_path is not None
        assert pdf_path.exists()
        assert pdf_path.name == "packing_slip_TEST-001.pdf"

        # Print the generated PDF (dry run)
        result = self.print_manager.print_documents([pdf_path])
        assert result is True

        # Clean up generated file
        pdf_path.unlink()

    def test_generate_and_print_multiple_pdfs(self):
        """Test workflow with multiple PDFs"""
        self.config.DRY_RUN = True

        # Generate multiple test orders
        order1 = self.test_order.copy()
        order1["order_id"] = "TEST-001"

        order2 = self.test_order.copy()
        order2["order_id"] = "TEST-002"

        # Generate PDFs
        pdf1 = self.packing_generator.generate_packing_slip(order1)
        pdf2 = self.packing_generator.generate_packing_slip(order2)

        assert pdf1 is not None
        assert pdf2 is not None

        # Test printing multiple PDFs
        result = self.print_manager.print_documents([pdf1, pdf2])
        assert result is True

        # Clean up
        if pdf1.exists():
            pdf1.unlink()
        if pdf2.exists():
            pdf2.unlink()

    @patch("app.print.subprocess.run")
    def test_print_real_generated_pdf(self, mock_run):
        """Test printing a real PDF generated by packing module"""
        # Mock successful print command
        mock_run.return_value = Mock(returncode=0)

        # Generate a real PDF
        pdf_path = self.packing_generator.generate_packing_slip(self.test_order)

        assert pdf_path is not None
        assert pdf_path.exists()

        # Test printing the real PDF using public interface
        result = self.print_manager.print_documents([pdf_path])
        assert result is True

        # Verify print command was called
        mock_run.assert_called_once()

        # Clean up
        pdf_path.unlink()

    def test_workflow_with_missing_pdf(self):
        """Test error handling when PDF generation fails"""
        # Mock failed PDF generation
        with patch.object(
            self.packing_generator, "generate_packing_slip", return_value=None
        ):
            pdf_path = self.packing_generator.generate_packing_slip(self.test_order)
            assert pdf_path is None

            # Printing should handle None gracefully
            # (This tests robustness of the workflow)

    def test_end_to_end_workflow_function(self):
        """Test a complete end-to-end workflow function"""
        self.config.DRY_RUN = True

        # This simulates what the main application workflow would look like
        def process_order_for_packing_and_printing(order_data):
            """Complete workflow: generate packing slip and print it"""
            # Step 1: Generate packing slip
            pdf_path = self.packing_generator.generate_packing_slip(order_data)
            if not pdf_path:
                return False

            # Step 2: Print the packing slip
            print_success = self.print_manager.print_documents([pdf_path])

            # Clean up in dry run mode
            if self.config.DRY_RUN and pdf_path.exists():
                pdf_path.unlink()

            return print_success

        # Test the complete workflow
        result = process_order_for_packing_and_printing(self.test_order)
        assert result is True

    @pytest.mark.print
    def test_actual_printer_print(self):
        """Test actual printing to hardware - only run manually with -m print"""
        # Use real config values (not mocked)
        real_config = Config()
        real_print_manager = PrintManager(real_config)

        # Generate a real PDF to print
        pdf_path = self.packing_generator.generate_packing_slip(self.test_order)
        assert pdf_path is not None
        assert pdf_path.exists()

        print(
            f"\nüñ®Ô∏è  About to send actual print job to printer: {real_config.PRINTER_NAME}"
        )
        print(f"üìÑ Printing file: {pdf_path}")
        print("‚ö†Ô∏è  Make sure your printer is connected and ready!")

        # Actually print to hardware
        result = real_print_manager.print_documents([pdf_path])

        # Clean up the generated PDF
        pdf_path.unlink()

        assert result is True
        print("‚úÖ Print job sent successfully!")
